#!/bin/bash

#set -o errexit   # is more harmful than useful
                  # http://mywiki.wooledge.org/BashFAQ/105
                  # http://wiki.bash-hackers.org/scripting/obsolete
                  # https://github.com/yaccz/errexit-considered-harmful
#set -o nounset   # bad practice
set -o pipefail   # set the return value of a pipeline to the value of the rightmost
                  # command to exit with a non-zero status, or zero if all commands
                  # in the pipeline exit successfully.
shopt -s nullglob

readonly _SCRIPT_DIR="$( cd "$(dirname "$0")" && pwd -P )" || exit 1
_yes=0        #apply changes without user confirmation
_verbose=0    #show the action that made no change
_script_name= #name of currely running script

for _lib in "$_SCRIPT_DIR"/lib/*.sh; do
    # shellcheck disable=SC1090
    . "$_lib" || exit 1
done
unset _lib

_usage() {
    echo "Usage: $0 [OPTIONS] [SCRIPT...]" >&2
    echo "Options:" >&2
    echo " -h  show this message" >&2
    echo " -y  apply changes without your confirmation" >&2
    echo " -v  show the action that made no change" >&2
}

# parse args and output list of scripts to run
_parse_args() {
    while getopts hyv OPT; do
        case "$OPT" in
            h)
                _usage
                return 0
                ;;
            \?)
                _usage
                return 1
                ;;
            y) _yes=0 ;;
            v) _verbose=1 ;;
        esac
    done
    shift "$(( OPTIND - 1 ))"

    if (( $# == 0 )); then
        local script
        for script in "$_SCRIPT_DIR"/*.df.sh "$_SCRIPT_DIR"/*/main.df.sh; do
            echo "$script"
        done
    else
        local arg
        for arg in "$@"; do
            local arg_full="$_SCRIPT_DIR/$arg"

            local script
            if [[ -e $arg_full/main.df.sh ]]; then
                script="$arg_full/main.df.sh"
            else
                script="${arg_full}.df.sh"
            fi

            if [[ ! -e $script ]]; then
                echo "error: script $script not found" >&2
                return 1
            fi

            echo "$script"
        done
    fi
}

#output name of script $1
_get_script_name() {
    if [[ $1 =~ /main\.df\.sh$ ]]; then
        basename "$(dirname "$1")"
    else
        echo "${1%.df.sh}"
    fi
}

_scripts=$(_parse_args "$@") || exit 1

while IFS= read -r _script; do
    _script_name=$(_get_script_name "$_script") || exit 1

    # shellcheck disable=SC1090
    (cd "$(dirname "$_script")" && . "$_script") || exit 1
done <<< "$_scripts"

unset _scripts
