#!/bin/bash

#set -o errexit   # is more harmful than useful
                  # http://mywiki.wooledge.org/BashFAQ/105
                  # http://wiki.bash-hackers.org/scripting/obsolete
                  # https://github.com/yaccz/errexit-considered-harmful
#set -o nounset   # bad practice
set -o pipefail   # set the return value of a pipeline to the value of the rightmost
                  # command to exit with a non-zero status, or zero if all commands
                  # in the pipeline exit successfully.
shopt -s nullglob

readonly _SCRIPT_DIR="$( cd "$(dirname "$0")" && pwd -P )" || exit 1
_yes=0        #apply changes without user confirmation
_verbose=0    #show the action that made no change
_script_name= #name of currely running script
_changed=0    #whether last action was changed the system or not

for _lib in "$_SCRIPT_DIR"/lib/*.sh; do
    # shellcheck disable=SC1090
    . "$_lib" || exit 1
done
unset _lib

# join $2.. with $1.
_join() {
    local ifs_old=$IFS
    IFS=$1
    shift
    echo "$*"
    IFS=$ifs_old
}

# parse non-option parameters and output list of scripts to run
_parse_targets() {
    if (( $# == 0 )); then
        local script
        for script in "$_SCRIPT_DIR"/*.df.sh "$_SCRIPT_DIR"/*/main.df.sh; do
            echo "$script"
        done
    else
        local scripts=()
        local arg
        for arg in "$@"; do
            local arg_full="$_SCRIPT_DIR/$arg"

            local script
            if [[ -e $arg_full/main.df.sh ]]; then
                script="$arg_full/main.df.sh"
            else
                script="${arg_full}.df.sh"
            fi

            if [[ ! -e $script ]]; then
                echo "error: script $script not found" >&2
                return 1
            fi

            scripts+=("$script")
        done

        _join $'\n' "${scripts[@]}"
    fi
}

#output name of script $1
_get_script_name() {
    if [[ $1 =~ /main\.df\.sh$ ]]; then
        basename "$(dirname "$1")"
    else
        echo "${1%.df.sh}"
    fi
}

#show usage
_usage() {
    cat <<EOF
Usage: $0 [OPTIONS]... [SCRIPT]...
Options:
  -h, --help     display this help and exit
  -y, --yes      apply changes without your confirmation
  -v, --verbose  show the action that made no change
EOF
}

getopt --test >/dev/null 2>&1
if [[ $? -ne 4 ]]; then
    echo "This script needs GNU version of getopt."
    exit 1
fi

if ! _temp=$(getopt --name "$0" --options "hyv" --longoptions "help,yes,verbose" -- "$@"); then
    _usage
    exit 1
fi

eval set -- "$_temp"
unset _temp

while :; do
    case "$1" in
        -h|--help)
            _usage
            exit 0
            ;;
        -y|--yes)
            _yes=1
            shift
            ;;
        -v|--verbose)
            _verbose=1
            shift
            ;;
        --)
            shift
            break
            ;;
    esac
done

# dup stdin to fd 3
exec 3<&0

_parse_targets "$@" | while IFS= read -r _script; do
    _script_name=$(_get_script_name "$_script") || exit 1

    # shellcheck disable=SC1090
    (cd "$(dirname "$_script")" && . "$_script") <&3 || exit 1
done

# close fd 3
exec 3<&-

echo
