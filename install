#!/bin/bash
# dotfiles
# Copyright (C) 2017  Kazutoshi Noguchi
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#set -o errexit   # is more harmful than useful
                  # http://mywiki.wooledge.org/BashFAQ/105
                  # http://wiki.bash-hackers.org/scripting/obsolete
                  # https://github.com/yaccz/errexit-considered-harmful
#set -o nounset   # bad practice
set -o pipefail   # set the return value of a pipeline to the value of the rightmost
                  # command to exit with a non-zero status, or zero if all commands
                  # in the pipeline exit successfully.
shopt -s nullglob

#absolute path to the directory of this script
readonly _SCRIPT_DIR="$( cd "$(dirname "$0")" && pwd -P )" || exit 1

if [[ -t 1 ]]; then
    readonly _COLOR_FAILED=$(tput setaf 1) || exit 1  #red
    readonly _COLOR_OK=$(tput setaf 2) || exit 1      #green
    readonly _COLOR_CHANGED=$(tput setaf 3) || exit 1 #yellow
    readonly _COLOR_RESET=$(tput sgr0) || exit 1
    readonly _ERASE_TO_EOL=$(tput el) || exit 1
else
    readonly _COLOR_FAILED=
    readonly _COLOR_OK=
    readonly _COLOR_CHANGED=
    readonly _COLOR_RESET=
    readonly _ERASE_TO_EOL=
fi

_dry_run=0       #perform a trial run with no changes made if this is true
_verbose=0       #show the action that made no change if this is true
_script_name=    #name of currely running script
_changed=0       #whether last action was changed the system or not
declare -A _args #last result of _parse_action_args
_varargs=()      #last result of _parse_action_args

is_dry_run() {
    (( _dry_run ))
}

_reset_changed() {
    _changed=0
}

is_changed() {
    (( _changed ))
}

_flag_changed() {
    _changed=1
}

_hide_progress() {
    [[ -t 1 ]] && echo -n "$_ERASE_TO_EOL"
}

_failure_reason() {
    _hide_progress
    echo "$*" >&2
}

# define function $1 which calls $2 and show its progress
_define() {
    if (( $# != 2 )); then
        echo "Wrong number of arguments" >&2
        return 1
    fi

    local action_quoted impl_quoted
    action_quoted=$(printf %q "$1") || return 1
    impl_quoted=$(printf %q "$2") || return 1

    eval "
$action_quoted() {
    _reset_changed
    [[ -t 1 ]] && echo -n \"           \$_script_name: $action_quoted \$*\"\$'\\r'

    if ! $impl_quoted \"\$@\"; then
        echo \"[ \${_COLOR_FAILED}FAILED\${_COLOR_RESET} ] \$_script_name: $action_quoted \$*\"
        exit 1
    fi

    if is_changed; then
        echo \"[\${_COLOR_CHANGED}CHANGED\${_COLOR_RESET} ] \$_script_name: $action_quoted \$*\"
        return 0
    fi

    echo -n \"[   \${_COLOR_OK}OK\${_COLOR_RESET}   ] \$_script_name: $action_quoted \$*\"
    [[ -t 1 ]] && (( ! _verbose )) && echo -n \$'\\r' || echo

    return 0
}"

    return 0
}

#usage: _parse_action_args SPEC... -- "$@"
_parse_action_args() {
    _args=()
    _varargs=()

    local non_option_args=()
    local allow_varargs=0
    local flags=()
    local options=()

    while :; do
        if (( $# == 0 )); then
            _failure_reason "Missing '--'"
            return 1
        fi
        case "$1" in
            --)
                shift
                break
                ;;
            ...)
                allow_varargs=1
                shift
                ;;
            --*:)
                local option_name=${1:2:-1}
                options+=("$option_name")
                shift
                ;;
            --*)
                local flag_name=${1:2}
                flags+=("$flag_name")
                _args[$flag_name]=0
                shift
                ;;
            *)
                non_option_args+=("$1")
                shift
                ;;
        esac
    done

    local longoptions=("${flags[@]}")
    local option_name
    for option_name in "${options[@]}"; do
        longoptions+=("$option_name:")
    done

    local temp
    if ! temp=$(getopt --longoptions="$(_join , "${longoptions[@]}")" -- parse_action_args "$@"); then
        return 1
    fi

    eval set -- "$temp"

    while :; do
        if [[ $1 = "--" ]]; then
            shift
            break
        fi

        local flag_name
        for flag_name in "${flags[@]}"; do
            if [[ $1 = "--$flag_name" ]]; then
                _args[$flag_name]=1
                shift
                break
            fi
        done

        local option_name
        for option_name in "${options[@]}"; do
            if [[ $1 = "--$option_name" ]]; then
                _args[$option_name]=$2
                shift 2
                break
            fi
        done
    done

    if (( $# < ${#non_option_args[@]} || \
          !allow_varargs && $# > ${#non_option_args[@]} )); then
        _failure_reason "Wrong number of arguments"
        return 1
    fi

    local i=0
    while (( i < ${#non_option_args[@]} )); do
        # shellcheck disable=SC2034
        _args[${non_option_args[$i]}]=$1
        shift
        (( i++ ))
    done

    # shellcheck disable=SC2034
    _varargs=("$@")

    return 0
}

_needs_exec() {
    if ! which "$1" >/dev/null 2>&1; then
        _failure_reason "missing required command $1"
        return 1
    fi

    return 0
}

for _lib in "$_SCRIPT_DIR"/lib/*.sh; do
    # shellcheck disable=SC1090
    . "$_lib" || exit 1
done
unset _lib

# join $2.. with $1.
_join() {
    local ifs_old=$IFS
    IFS=$1
    shift
    echo "$*"
    IFS=$ifs_old
}

# parse non-option parameters and output list of a absolute path to scripts to run
_parse_targets() {
    if (( $# == 0 )); then
        local script
        for script in *.df.sh */main.df.sh; do
            echo "$(pwd -P)/$script"
        done
    else
        local scripts=()
        local arg
        for arg in "$@"; do
            local script
            if [[ -e $arg/main.df.sh ]]; then
                script="$arg/main.df.sh"
            elif [[ -e ${arg}.df.sh ]]; then
                script="${arg}.df.sh"
            else
                script=$arg
            fi

            if [[ ! -e $script ]]; then
                echo "error: script $script not found" >&2
                return 1
            fi

            scripts+=("$(pwd -P)/$script")
        done

        _join $'\n' "${scripts[@]}"
    fi
}

#output name of script $1
_get_script_name() {
    if [[ $1 =~ /main\.df\.sh$ ]]; then
        basename "$(dirname "$1")"
    else
        local filename
        filename=$(basename "$1")
        echo "${filename%.df.sh}"
    fi
}

#show usage
_usage() {
    cat <<EOF
Usage: $0 [OPTIONS]... [SCRIPT]...
Options:
  -h, --help            display this help and exit
  -n, --dry-run         perform a trial run with no changes made
  -v, --verbose         show the action that made no change
EOF
}

getopt --test >/dev/null 2>&1
if (( $? != 4 )); then
    echo "This script needs util-linux version of getopt."
    exit 1
fi

if ! _temp=$(getopt --name "$0" --options "hnv" --longoptions "help,dry-run,verbose" -- "$@"); then
    _usage
    exit 1
fi

eval set -- "$_temp"
unset _temp

while :; do
    case "$1" in
        -h|--help)
            _usage
            exit 0
            ;;
        -n|--dry-run)
            _dry_run=1
            shift
            ;;
        -v|--verbose)
            _verbose=1
            shift
            ;;
        --)
            shift
            break
            ;;
    esac
done

# dup stdin to fd 3
exec 3<&0

_parse_targets "$@" | while IFS= read -r _script; do
    # shellcheck disable=SC2034
    _script_name=$(_get_script_name "$_script") || exit 1

    # shellcheck disable=SC1090
    (cd "$(dirname "$_script")" && . "$_script") <&3 || exit 1
done || exit 1

# close fd 3
exec 3<&-

if [[ -t 1 ]] && (( ! _verbose )) && ! is_changed; then
    #print newline to avoid that the shell prompt overwrite the output
    echo
fi
